import { Prop } from '@nestjs/mongoose';
import { Component, Event, EventEmitter, h, State, Method, Watch } from '@stencil/core';

import { SlDropdown } from '@shoelace-style/shoelace';

@Component({
  tag: 'tk-add-tags',
  styleUrl: 'tk-add-tags.css',
  shadow: false,
})
export class TkAddTags {

  @Event() notifyUpdateTags: EventEmitter;

  @Prop() existingTags;
  @Prop() currentTags = [];
  @Prop() generatedTags = [];

  @State() tags = [];
  @State() matchedTags = [];

  externalTags;
  internalTags;

  componentWillLoad() {
    this.externalTags = this.generatedTags;
    this.internalTags = this.currentTags;
  }

  @Method()
  async getTags() {
    return this.tags;
  }

  @Method()
  async clearTags() {
    this.tags = [];
  }

  @Watch('currentTags')
  currentTagsHandler (newValue) {
    //console.log(`currentTags will be updated from ${JSON.stringify(oldValue)} to ${JSON.stringify(newValue)}`);  
    this.internalTags = newValue;
    this.combineTags();
  }

  @Watch('generatedTags') 
  generatedTagsHanlder (newValue) {
    this.externalTags = newValue;
    this.combineTags();
  }

  combineTags() {
    let combinedTags = [];
    this.internalTags.map(internalTag => {
      internalTag.isExternal = false;
      combinedTags.push(internalTag)
    });
    this.externalTags.map(externalTag => {
      externalTag.isExteral = true;
      combinedTags.push(externalTag)
    });
    this.tags = [...combinedTags];
  }

  convertValueToTags(event, value) {
    if(this.matchedTags.length > 0) {
      return;
    }

    console.log(`convertValueToTags() called with ${value}`);

    //let value = event.target.value;
    if(value && value.trim()) {
      this.addTag(value);
      event.target.value = '';
    }
  }

  findExistingTag(caption) {
    return this.existingTags.find(tag => tag.caption.toLowerCase() == caption.toLowerCase());
  }

  setTag(event, tagCaption) {
    if(!event) {
      console.log(`setTag() called without event for ${tagCaption}`);
    }
    let tagInput = document.querySelector('.tagInput') as HTMLInputElement;
    this.addTag(tagCaption);
    tagInput.value = '';
  }

  removeTag(targetTag) {
    this.internalTags = this.internalTags.filter(tag => {
      return tag.caption !== targetTag.caption
    });
    this.externalTags = this.externalTags.filter(tag => {
      return tag.caption !== targetTag.caption
    });
    this.updateTags();
  }

  addTag(tagCaption) {
    console.log(`addTag called with ${tagCaption}`);

    let targetTag = this.tags.find(currentTag => {
      return currentTag.caption === tagCaption
    });
    if(targetTag) {
      console.log(`already existing tag - not going to add one`);
      return;
    }

    this.internalTags.push({caption: tagCaption});
    //console.log(`about to call updateTags with ${JSON.stringify(this.tags)}`);
    this.updateTags();
  }

  updateTags() {
    //this.tags = [...result];
    this.combineTags();
    this.notifyUpdateTags.emit(this.tags);
  }

  findMatchedTags(value) {
    let result = [];
    this.existingTags.map(existingTag => {
      if(existingTag.caption.toLowerCase().includes(value.toLowerCase())) {
        result.push(existingTag);
      }
    });
    return result;
  }

  handleLabelInput(event) {
    let enteredValue = event.target.value;
    //console.log(`keyUp: ${enteredValue}`);
    //if(enteredValue && enteredValue.trim()) {
      //construct menu on the fly
      this.matchedTags = [...this.findMatchedTags(enteredValue)];
      //console.log(`there are ${this.matchedTags.length} labels found`);
      let dropdownElement = document.querySelector('.matchedTagDropdown') as SlDropdown;
      
      if(this.matchedTags.length > 0) {
        dropdownElement.show();
      } else {
        dropdownElement.hide();
      }
    //}
  }

  getTagVariant(tag) {
    let targetTag = this.externalTags.find(externalTag => {
      return externalTag.caption === tag.caption
    });
    if(targetTag) {
      return 'primary';
    }

    targetTag = this.existingTags.find(existingTag => {
      return existingTag.caption === tag.caption
    });
    console.log(`check ${tag.caption}, targetTag: ${JSON.stringify(targetTag)}`);
    if(targetTag) {
      return 'neutral';
    }

    return 'success';
  } 

  renderTags() {
    // console.log(`renderTags() called with ${JSON.stringify(this.tags)}`);

    return (
      this.tags.map(tag =>
        <sl-tag style={{padding: '5px'}} variant={this.getTagVariant(tag)} size="medium" removable
          onClick={()=>this.removeTag(tag)}>{tag.caption}</sl-tag>
      )
    );
  }

  renderForDebug() {
    return (
      <div>
        <sl-input value={`EXT: ${JSON.stringify(this.externalTags)}`}></sl-input>
        <sl-input value={`INT: ${JSON.stringify(this.internalTags)}`}></sl-input>
        <sl-input value={`Current: ${JSON.stringify(this.currentTags)}`}></sl-input>
        <sl-input value={`AutoGenerated: ${JSON.stringify(this.generatedTags)}`}></sl-input>
      </div>
    );
  }

  render() {
    return (
      <div class="tk-add-tags-holder">
        {/* {this.renderForDebug()} */}
        {this.renderTags()}
        <sl-input class="tagInput" style={{padding:'10px'}} placeholder="Labels"
          onKeyUp={(event)=>{this.handleLabelInput(event)}}
          onBlur={(event)=>this.convertValueToTags(event, event.target.value)}></sl-input>
        <sl-dropdown class="matchedTagDropdown" style={{position: 'relative', top: '-20px', left: '20px'}}>
          <sl-menu>
            {this.matchedTags.map(matchedTag =>
              <sl-menu-item onClick={(event) => this.setTag(event, matchedTag.caption)}>{matchedTag.caption}</sl-menu-item>
            )}
          </sl-menu>
        </sl-dropdown>
        
      </div>
    );
  }

}
