import { Prop } from '@nestjs/mongoose';
import FuzzySet from 'fuzzyset';
import { Component, Event, EventEmitter, h, State, Watch } from '@stencil/core';

import state from '../../../stores/tk-bookmark-store';
import { getLabelIdsFromExistingLabels } from '../../../utils/tk-bookmark-app-utils';

@Component({
  tag: 'tk-add-or-edit-bookmark',
  shadow: false,
})
export class TkAddOrEditBookmark {

  @Event() addBookmarkSuccess: EventEmitter;
  @Event() closeAddBookmark: EventEmitter;
  @Event() notifyUpdateRequestObject: EventEmitter;

  @Prop() forNewBookmark: boolean;
  @Prop() hideNextButton: boolean;
  @Prop() bookmark;
  @Prop() existingTags;
  @Prop() overrideState;

  @State() requestObject = {
    title: '',
    url: '',
    notes: '',
    labels: [],
    user: ''
  };

  currentTags = [];
  @State() autoGeneratableTags = [];

  componentWillLoad() {
    this.initialize();
  }

  async initialize() {
    if(this.overrideState) {
      state.baseUrl = this.overrideState.baseUrl;
      state.bookmarkApi = this.overrideState.bookmarkApi;
    }
    this.requestObject.user = state.user.email;

    if(this.bookmark) {
      console.log(`initial bookmark (passed via prop?) detected ${JSON.stringify(this.bookmark)}`);
      this.updateBookmark(this.bookmark);
    }
  }

  @Watch('bookmark')
  handleBookmarkChange(newBookmark) {
    console.log(`bookmark change detected ${JSON.stringify(newBookmark)}`);
    this.updateBookmark(newBookmark);
  }

  updateBookmark(newBookmark) {
    this.requestObject = {...newBookmark};
    this.currentTags = this.convertToCurrentTags();
    if(this.forNewBookmark) {
      this.autoGeneratableTags = this.getAutoGeneratableTags(this.requestObject.title);
      console.log(`auto generatable tag before render is of ${JSON.stringify(this.autoGeneratableTags)}`);
    }
    this.updateGeneratedTags();
  }

  findTag(tags, targetTag) {
    if(tags && targetTag) {
      return tags.find(tag => tag.caption === targetTag.caption);
    }
    return null;
  }

  updateGeneratedTags() {
    let generatedTags = [];
    if(this.autoGeneratableTags && this.autoGeneratableTags.length > 0) {
      this.autoGeneratableTags.map(autoGeneratedTag => {
        let tagMatchWithCurrentTag = this.findTag(generatedTags, autoGeneratedTag);
        if(!tagMatchWithCurrentTag) {
          generatedTags.push(autoGeneratedTag);
        }
      });
    }
    this.autoGeneratableTags = [...generatedTags];
  }

  getAutoGeneratableTags(title) {
    let autoGeneratableLabels = [];
    
    if(!this.existingTags || this.existingTags.length === 0) {
      return autoGeneratableLabels;
    }
    
    let existingTagWords = this.existingTags.map(tag => tag.caption);
    let checker = FuzzySet(existingTagWords);

    let titleWords = title.split(' ');
    titleWords.map(titleWord => {
      let result = checker.get(titleWord);
      let matchedObject = this.getFuzzyMatchResult(0.75, result);
      if(matchedObject !== null) {
        console.log(`word: ${titleWord}, result: ${JSON.stringify(result)}`);
        autoGeneratableLabels.push(matchedObject);
      }
    });

    return autoGeneratableLabels;
  }

  getFuzzyMatchResult(threshold, result) {
    if(result && result.length > 0) {
      let bestMatch = result[0];
      if(bestMatch[0] > threshold) {
        console.log(`>>>found match! adding tag: ${bestMatch[1]}`);
        return {
          caption: bestMatch[1]
        };
      }
    }
    return null;
  }

  handleRequestObjectChange(key, value) {
    this.requestObject[key] = value;
    this.requestObject = {...this.requestObject};
    this.notifyUpdateRequestObject.emit(this.requestObject);

    if(key === 'title' && this.forNewBookmark) {
      this.autoGeneratableTags = this.getAutoGeneratableTags(value);
      this.updateGeneratedTags();
    }
  }

  async createLabel(requestData) {
    return fetch(`${state.bookmarkApi}/label`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestData)
    }).then(res => res.json());
  }

  clearForm() {
    let titleInput = document.querySelector('.bookmarkTitle') as HTMLInputElement;
    titleInput.value = '';
    let urlInput = document.querySelector('.bookmarkUrl') as HTMLInputElement;
    urlInput.value = '';
    let notesInput = document.querySelector('.bookmarkNotes') as HTMLInputElement;
    notesInput.value = '';
    titleInput.focus();

    this.requestObject = {
      title: '',
      url: '',
      notes: '',
      labels: [],
      user: ''
    };
    this.requestObject = {...this.requestObject};
  }

  async createNewLabelIds() {
    let newLabelIds = [];

    let newLabels = await document.querySelector('tk-add-tags').getTags();
    let existingLabels = state.labels;
    console.log(`size of new labels: ${newLabels.length}`);
    console.log(`size of existing labels: ${state.labels.length}`);

    //goal is to construct newLabelIds[]
    newLabels.map(async newLabel => {
      let existingLabel = existingLabels.find(label => {
        return label.caption.toLowerCase() === newLabel.caption.toLowerCase();
      });
      if(existingLabel) {
        console.log(`found ${existingLabel.caption} within existing label list`);
        newLabelIds.push(existingLabel._id);
      } else {
        console.log(`found new label: ${newLabel.caption}`);
        let newLabelData = await this.createLabel({
          caption: newLabel.caption,
          user: state.user.email
        });
        newLabelIds.push(newLabelData._id);
      }
    });
    console.log(`constructed ids: ${newLabelIds}`);
    return newLabelIds;
  }

  async addBookmarkData(stayInAdd) {
    let newLabelIds = await getLabelIdsFromExistingLabels(state.labels);
    this.requestObject['labels'] = newLabelIds;
    
    fetch(`${state.bookmarkApi}/bookmark`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(this.requestObject)
    }).then(()=> {
      if(stayInAdd) {
        this.clearForm();
      }
      this.addBookmarkSuccess.emit({stayInAdd: stayInAdd, reloadLabel: true});
    });
  }

  cancelAdd() {
    this.closeAddBookmark.emit();
  }

  getStyleForNextButton() {
    if(this.hideNextButton) {
      return {display: 'none'};
    }
    return {};
  }

  shouldDisableButton() {
    return !this.requestObject.title || !this.requestObject.url;
  }

  renderActionBar() {
    if(this.forNewBookmark) {
      return (
        <div style={{padding: '5px'}}>
          <sl-button variant="primary" style={{padding: '5px'}}
            disabled={this.shouldDisableButton()}
            onClick={()=>this.addBookmarkData(false)}>Add</sl-button>
          <sl-button variant="default" style={this.getStyleForNextButton()}
            disabled={this.shouldDisableButton()}
            onClick={()=>this.addBookmarkData(true)}>Next</sl-button>
          <sl-button variant="text"
            onClick={()=>this.cancelAdd()}>Cancel</sl-button>
        </div>
      );
    }
  }

  convertToCurrentTags() {
    let existingLabels = state.labels;
    let currentTags = [];

    if(this.requestObject.labels) {
      this.requestObject.labels.map(labelId => {
        let existingLabel = existingLabels.find(existingLabel => existingLabel._id === labelId);
        if(existingLabel) {
          currentTags.push({caption: existingLabel.caption})
        }
      });
    }
    return currentTags;
  }

  // renderAutoGenButton() {
  //   if(!this.forNewBookmark) {
  //     return;
  //   }
  //   return (
  //     <sl-button slot="suffix">Generate</sl-button>
  //   );
  // }

  render() {
    // console.log(`tk-add-or render() called w/ ${JSON.stringify(this.requestObject)}`);
    return (
      <div style={{padding: '10px', backgroundColor: 'cornsilk'}}>
        <sl-input class="bookmarkTitle" name="bookmarkTitle" placeholder="Title" value={this.requestObject.title}
          onBlur={(e)=>this.handleRequestObjectChange('title', e.target.value)}>
          {/* {this.renderAutoGenButton()} */}
        </sl-input>
        <sl-input class="bookmarkUrl" name="bookmarkUrl" placeholder="URL" value={this.requestObject.url}
          onBlur={(e)=>this.handleRequestObjectChange('url', e.target.value)}>  
        </sl-input>
        <tk-add-tags currentTags={this.currentTags} generatedTags={this.autoGeneratableTags} existingTags={this.existingTags}></tk-add-tags>
        <sl-textarea class="bookmarkNotes" name="bookmarkNotes" label="Notes" value={this.requestObject.notes}
          onBlur={(e)=>this.handleRequestObjectChange('notes', e.target.value)}></sl-textarea>

        {/* {console.log(`tk-add-or-edit-bookmark passing ${JSON.stringify(this.requestObject)}`)} */}
        {console.log(`tk-add-or-edit-bookmark render() currentTags: ${JSON.stringify(this.currentTags)}`)}
        {console.log(`tk-add-or-edit-bookmark render() generatedTags: ${JSON.stringify(this.autoGeneratableTags)}`)}

        {this.renderActionBar()}
      </div>
    );
  }

}
